// slim -d N_G=10000 -d POP_S=3000 -d AL=0.8 -d DEL=0.2 -d C=0.01 -d MUT=0.005 -d SI=0.01 -d N_S=200 simple_model.slim
initialize() {
	setwd("/home/samuel/Desktop/test");
	initializeSLiMModelType("nonWF");
	
	// SET TO TRUE IF YOU WANT TO PREVENT INCIDENTAL SELFING
	initializeSLiMOptions(preventIncidentalSelfing=F); 
	
	defineConstant("N_GEN", N_G); // number of generation
	defineConstant("POP_SIZE", POP_S); // population size (will be constant during the simulation)
	defineConstant("ALPHA", AL); // proportion of pollen kept by each individual on its own stigmas
	defineConstant("DELTA", DEL); // inbreeding depression
	defineConstant("MIGRATION", MIG); // migration rate of seeds between patches
	defineConstant("COST", C); // controls the effect of plasticity on fertility 
	defineConstant("MUT_RATE", MUT); // mutation rate
	defineConstant("SIGMA", SI); // mutation effect standard deviation
	defineConstant("N_SAMPLE", N_S); // number of individuals to sample every 1000 generation (to track the evolution of sex allocation)
	
	// creates mutation types, genomic elements and set mutation and recombination rates
	initializeMutationRate(MUT_RATE);
	initializeMutationType("m1", 0.5, "n", 0.0, SIGMA); 
	initializeMutationType("m2", 0.5, "n", 0.0, SIGMA);
	c(m1, m2).mutationStackPolicy = "l";
		
	initializeGenomicElementType("g1", m1, 1.0); 
	initializeGenomicElementType("g2", m2, 1.0);
	
	initializeGenomicElement(g1, 0, 0); 
	initializeGenomicElement(g2, 1, 1);
	initializeRecombinationRate(0.0);
	
	catn("------------------------");
	catn("PARAMETERS");
	catn("N_GEN=" + N_G + ", POP_SIZE=" + POP_S + ", ALPHA=" + AL + ", DELTA=" + DEL + ", MIGRATION=" + MIG + ", COST=" + C + ", MU=" + MUT + ", SIGMA=" + SI + ", N_SAMPLE=" + N_S);
	catn("------------------------");
	
}

/// ** CALLBACKS **

//locus 1(a) and 2(b) evolve according to a continuum-of-allele model 
mutation(m1) {
	ancestral_value = haplosome.sumOfMutationsOfType(m1);
	mut.setSelectionCoeff(ancestral_value + mut.selectionCoeff);
	return T;
}
mutation(m2) {
	ancestral_value = haplosome.sumOfMutationsOfType(m2);
	mut.setSelectionCoeff(ancestral_value + mut.selectionCoeff);
	return T;
}

// survival is independant of fitness, only the offsprings survive and become parents
survival() {
	return (individual.age == 0);
}

// reproduction is based on the fertilty of individuals (i.e. the amount of gamete they produced)
reproduction() {
	inds = p1.individuals;
	
	// sample resource budget from a uniform distribution between 0 and 1
	resources = runif(POP_SIZE);
	
	// calculates the phenotypes of each individuals
	a = inds.sumOfMutationsOfType(1)/2;
	b = inds.sumOfMutationsOfType(2)/2;
	
	// calculates sex allocation z based on phenotype a (the slope) and b (the intercept)
	z = clamp(a * resources + b);
	
	// calculates amount of gamete of each type produced based on sex allocation and resource budget
	// account for the cost of plasticity
	female_gametes = z * resources * exp(-COST*a*a);
	male_gametes = (1-z) * resources * exp(-COST*a*a);
	
	// calculates selfing rates based on amount of gamete produced by each individual (mass action process)
	alphaM = ALPHA * male_gametes;
	selfing_rates = alphaM / (alphaM + (1-ALPHA) * (sum(male_gametes) - male_gametes) / (POP_SIZE - 1));
	inds.tagF = selfing_rates;
	
	// calculates the amount of seeds produced by each individual (taking in account selfing rate & inbreeding depression)
	seeds = female_gametes * (1 - selfing_rates * DELTA);
	
	// ***************
	// **** local ****
	// ***************	
	// calculates probability that a patch will be colonized by a seed coming from the individual growing on that same patch
	
	// calculates the amount of seeds that does not disperse on other patches
	local_seeds = seeds * (1 - MIGRATION);
	
	// probability that a local seed will colonize each patch
	p_local = local_seeds / (local_seeds + MIGRATION * (sum(seeds) - seeds) / (POP_SIZE - 1));
	
	is_local = runif(POP_SIZE) < p_local;
	dam_local = inds[is_local]; // patches (i.e. dams) that will have a local offspring
	
	// calculates the probability that the local offspring will be born through selfing
	p_selfing_and_local = dam_local.tagF * (1 - DELTA) / ( 1 - dam_local.tagF * DELTA); 
	is_selfing_and_local = runif(sum(is_local)) < p_selfing_and_local;
	
	for (d_s in dam_local[is_selfing_and_local]) p1.addSelfed(d_s); // selfing
	
	is_outcrossing_and_local = is_selfing_and_local == F;
	dam_local_outcrossing = dam_local[is_outcrossing_and_local];
	
	// sample sires for local offspring that will be born through outcrossing
	sires_for_dam_local_outcrossing = sample(inds, size=sum(is_outcrossing_and_local), replace=T, weights=male_gametes);
	
	for (i in seqAlong(dam_local_outcrossing)) { // outcrossing (note that there is a probability P=1/POP_SIZE that selfing still happens)
		p1.addCrossed(dam_local_outcrossing[i], sires_for_dam_local_outcrossing[i]); 
	}
	
	/*
	
	Block of code that makes sure that there is no incidental selfing when outcrossing should happen
	Safer but slower !
	
	for (d_o in dam_local[is_selfing_and_local == F]) { // outcrossing
		do sire = sample(inds, size=1, weights=male_gametes);
		while (sire == d_o);
		p1.addCrossed(d_o, sire);
	}
	*/
	
	// *******************
	// **** not local ****
	// *******************
	// creating offsprings for patches where the offspring will not have the local dam as its mother
	is_not_local = is_local == F;
	dam_not_local = inds[is_not_local]; // patches where dams will not have an offspring maternally
	n_not_local = sum(is_not_local);
	
	// sample sires for non local offsprings (in case of outcrossing)
	sires_for_dam_not_local = sample(inds, size=n_not_local, replace=T, weights=male_gametes);
	
	// makes uniform sampling in advance to check whether selfing or outcrossing happens
	sampling_for_selfing = runif(n_not_local);
	
	for (i in seqAlong(dam_not_local)) {
		
		// sample randomly a dam and makes sure that it is not the local dam
		do dam = sample(inds, size=1, weights=seeds);
		while (dam == dam_not_local[i]); 
		
		// calculate the probability that the selected dam will self-fertilize
		p_self_and_not_local = dam.tagF * (1 - DELTA) / (1 - dam.tagF * DELTA);
		
		if (sampling_for_selfing[i] < p_self_and_not_local) p1.addSelfed(dam); // selfing
		else p1.addCrossed(dam, sires_for_dam_not_local[i]); // outcrossing (note that there is a probability P=1/POP_SIZE that selfing still happens)
			
	}
	
	/* 
	
	Block of code that makes sure that there is no incidental selfing when outcrossing should happen
	Safer but slower !
	
	for (d_n_l in dam_not_local) {
				
		do dam = sample(inds, size=1, weights=seeds);
		while (dam == d_n_l); // makes sure that the selected dam is not the local dam
		
		p_self_and_not_local = dam.tagF * (1 - DELTA) / (1 - dam.tagF * DELTA);
		
		if (runif(1) < p_self_and_not_local) p1.addSelfed(dam); // selfing
		else { // outcrossing
			do sire = sample(inds, size=1, weights=male_gametes);
			while (sire == dam);
			p1.addCrossed(dam, sire); 
		}
	}
	*/
	
	self.active = 0;
}

/// ** EVENTS **

1 early() { 
	// initialize population
	sim.addSubpop("p1", POP_SIZE);
	
	// set initial values of alleles a and b
	p1.haplosomes.addNewMutation(m1, selectionCoeff=0.0, position=0);
	p1.haplosomes.addNewMutation(m2, selectionCoeff=0.5, position=1);
	
	// creates file for saving data troughout the simultion
	ind_id = c();
	for (i in 1:N_SAMPLE) ind_id = c(ind_id, paste("Ind", i, sep=""));
	hapl_id = c();
	for (i in 1:N_SAMPLE) hapl_id = c(hapl_id, paste("Hapl", i, sep=""));
	
	file_name = paste(c("alpha", ALPHA, "delta", DELTA, "cost", COST, "mu", MUT_RATE, "sigma", SIGMA, "gen", N_GEN, "popsize", POP_SIZE, "nsampled", N_SAMPLE, "seed", getSeed()), sep="_");
	file_name = paste(file_name, ".txt", sep="");
	defineConstant("FILE_NAME", file_name);
	columns_name = paste(c("generation", "param", ind_id, hapl_id), sep="\t");
	writeFile(FILE_NAME, columns_name, append=T);
}

2:N_GEN first() {
	
	// sample a few individuals every 1000 generation to follow the evolution of sex allocation
	if (sim.cycle % 1000 == 0 | sim.cycle == 10) { 
	
		gen = sim.cycle;
		
		catn(gen + ":");
		catn("slope: " + mean(p1.individuals.sumOfMutationsOfType(1)/2));
		catn("intercept: " + mean(p1.individuals.sumOfMutationsOfType(2)/2));
		
		inds_sampled = sample(p1.individuals, N_SAMPLE);
		a_ind = inds_sampled.sumOfMutationsOfType(1)/2;
		b_ind = inds_sampled.sumOfMutationsOfType(2)/2;	
		
		hapl_sampled = sample(p1.haplosomes, N_SAMPLE);
		a_hapl = hapl_sampled.sumOfMutationsOfType(1);
		b_hapl = hapl_sampled.sumOfMutationsOfType(2);
		
		line_slope = paste(c(gen, "slope", a_ind, a_hapl), sep="\t");
		line_intercept = paste(c(gen, "intercept", b_ind, b_hapl), sep="\t");
		
		writeFile(FILE_NAME, line_slope, append=T);
		writeFile(FILE_NAME, line_intercept, append=T);
		
	}
}

/// ** FUNCTIONS ** 

function (float)clamp(float v) {
	return pmax( pmin(v, 1.0), 0.0);
}
