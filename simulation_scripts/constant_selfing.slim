// slim -d N_G=10000 -d POP_S=3000 -d SELF_R=0.8 -d DEL=0.2 -d C=0.01 -d MUT=0.005 -d SI=0.01 -d N_S=200 constant_selfing.slim
initialize() {
	setwd("/home/samuel/Desktop/test");
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(preventIncidentalSelfing=T);
	
	defineConstant("N_GEN", N_G); // number of generation
	defineConstant("POP_SIZE", POP_S); // population size (will be constant during the simulation)
	defineConstant("SELFING_RATE", SELF_R); // selfing rate (fixed and equal for every individual)
	defineConstant("DELTA", DEL); // inbreeding depression
	defineConstant("COST", C); // controls the effect of plasticity on fertility 
	defineConstant("MUT_RATE", MUT); // mutation rate
	defineConstant("SIGMA", SI); // mutation effect standard deviation
	defineConstant("N_SAMPLE", N_S); // number of individuals to sample every 100 generation (to track the evolution of sex allocation)
	
	// creates mutation types, genomic elements and set mutation and recombination rates
	initializeMutationRate(MUT_RATE);
	initializeMutationType("m1", 0.5, "n", 0.0, SIGMA); 
	initializeMutationType("m2", 0.5, "n", 0.0, SIGMA);
	c(m1, m2).mutationStackPolicy = "l";
		
	initializeGenomicElementType("g1", m1, 1.0); 
	initializeGenomicElementType("g2", m2, 1.0);
	
	initializeGenomicElement(g1, 0, 0); 
	initializeGenomicElement(g2, 1, 1);
	initializeRecombinationRate(0.0);
	
	catn("------------------------");
	catn("PARAMETERS");
	catn("N_GEN=" + N_G + ", POP_SIZE=" + POP_S + ", SELFING_RATE=" + SELF_R + ", DELTA=" + DEL + ", COST=" + C + ", MU=" + MUT + ", SIGMA=" + SI + ", N_SAMPLE=" + N_S);
	catn("------------------------");
	
}

/// ** CALLBACKS **

//locus 1(a) and 2(b) evolve according to a continuum-of-allele model 
mutation(m1) {
	ancestral_value = haplosome.sumOfMutationsOfType(m1);
	mut.setSelectionCoeff(ancestral_value + mut.selectionCoeff);
	return T;
}
mutation(m2) {
	ancestral_value = haplosome.sumOfMutationsOfType(m2);
	mut.setSelectionCoeff(ancestral_value + mut.selectionCoeff);
	return T;
}


// survival is independant of fitness, only the offsprings survive and become parents
survival() {
	return (individual.age == 0);
}

// reproduction is based on the fertilty of individuals (i.e. the amount of gamete they produced)
reproduction() {
	inds = p1.individuals;
	
	// sample resource budget from a uniform distribution between 0 and 1	
	resources = runif(POP_SIZE);
	
	// calculate the phenotypes of each individuals
	a = inds.sumOfMutationsOfType(1)/2;
	b = inds.sumOfMutationsOfType(2)/2;
	
	// calculate sex allocation z based on phenotype a (the slope) and b (the intercept)
	z = clamp(a * resources + b);
	
	// calculate amount of gamete of each type produced based on sex allocation and resource budget
	// account for the cost of plasticity
	female_gametes = z * resources * exp(-COST*a*a);
	male_gametes = (1-z) * resources * exp(-COST*a*a);
	
	// calculating individual selfing rates is no longer needed since its is fixed a priori
	//alphaM = ALPHA * male_gametes;
	//selfing_rates = alphaM / (alphaM + (1-ALPHA) * (sum(male_gametes) - male_gametes) / (POP_SIZE - 1));
	//inds.tagF = selfing_rates;
	
	// creates offspring by batch until enough were created and survived
	offspring_count = 0;
	while (offspring_count < POP_SIZE) {	
		
		// number of offspring that still need to be created
		to_do = POP_SIZE - offspring_count;
		
		// sampling as many dams as their is offsprings that needs to be created
		dams = sample(inds, size = to_do, replace=T, weights=female_gametes);
		
		// checks if the potential offspring comes from selfing
		//is_selfing = runif(to_do) < dams.tagF;
		is_selfing = runif(to_do) < SELFING_RATE;
		
		total_selfing = sum(is_selfing);
		if (total_selfing>0) {
		
			//checks if it survives
			total_survivors = rbinom(n=1, size=total_selfing, prob=(1-DELTA));
			
			// if more than zero selfed offspring survives, creates the offspring(s)
			if (total_survivors > 0) { 
		
				offspring_count = offspring_count + total_survivors;	
				dams_selfing = dams[is_selfing][0:(total_survivors-1)];
				for (d_s in dams_selfing) p1.addSelfed(d_s);
			
			}
		}
		
		// the individuals that did not self-fertilize outcross
		is_outcrossing = (is_selfing==F);
		
		total_outcrossing = sum(is_outcrossing);
		if (total_outcrossing > 0) {
		
			offspring_count = offspring_count + total_outcrossing;
			dams_outcrossing = dams[is_outcrossing];
			
			// find mates for outcrossing dams
			for (d_o in dams_outcrossing) {
				do sire = sample(inds, size=1, weights=male_gametes);
				while(sire == d_o);
				p1.addCrossed(d_o, sire);
			}	
			
		}
	}	
	self.active = 0;
}

/// ** EVENTS **

1 early() { 
	// initialize population
	sim.addSubpop("p1", POP_SIZE);
	
	// set initial values of alleles a and b
	p1.haplosomes.addNewMutation(m1, selectionCoeff=0.0, position=0);
	p1.haplosomes.addNewMutation(m2, selectionCoeff=0.5, position=1);
	
	// creates file for saving data troughout the simultion
	ind_id = c();
	for (i in 1:N_SAMPLE) ind_id = c(ind_id, paste("Ind", i, sep=""));
	hapl_id = c();
	for (i in 1:N_SAMPLE) hapl_id = c(hapl_id, paste("Hapl", i, sep=""));
	
	file_name = paste(c("selfingrate", SELFING_RATE, "delta", DELTA, "cost", COST, "mu", MUT_RATE, "sigma", SIGMA, "gen", N_GEN, "popsize", POP_SIZE, "nsampled", N_SAMPLE, "seed", getSeed()), sep="_");
	file_name = paste(file_name, ".txt", sep="");
	defineConstant("FILE_NAME", file_name);
	columns_name = paste(c("generation", "param", ind_id, hapl_id), sep="\t");
	writeFile(FILE_NAME, columns_name, append=T);
}

2:N_GEN first() {
	
	// sample a few individuals every 100 generation to follow the evolution of sex allocation
	if (sim.cycle % 100 == 0) { 
	
		gen = sim.cycle;
		
		if (gen % 500 == 0) {
			catn(sim.cycle + ":");
			catn("slope: " + mean(p1.individuals.sumOfMutationsOfType(1)/2));
			catn("intercept: " + mean(p1.individuals.sumOfMutationsOfType(2)/2));
		}
		
		inds_sampled = sample(p1.individuals, N_SAMPLE);
		a_ind = inds_sampled.sumOfMutationsOfType(1)/2;
		b_ind = inds_sampled.sumOfMutationsOfType(2)/2;	
		
		hapl_sampled = sample(p1.haplosomes, N_SAMPLE);
		a_hapl = hapl_sampled.sumOfMutationsOfType(1);
		b_hapl = hapl_sampled.sumOfMutationsOfType(2);
		
		line_slope = paste(c(gen, "slope", a_ind, a_hapl), sep="\t");
		line_intercept = paste(c(gen, "intercept", b_ind, b_hapl), sep="\t");
		
		writeFile(FILE_NAME, line_slope, append=T);
		writeFile(FILE_NAME, line_intercept, append=T);
		
	}
}

/// ** FUNCTIONS ** 

function (float)clamp(float v) {
	return pmax( pmin(v, 1.0), 0.0);
}
